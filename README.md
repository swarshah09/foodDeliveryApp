# Food Delivery System (Microservices)

A full-stack microservices-based Food Delivery platform implementing the provided SRS.

## Stack

- Backend: Java 17, Spring Boot 3.x, Spring Cloud 2023.x
- Services: Eureka Server, API Gateway, User, Restaurant, Order, Payment, Delivery, Notification
- Database: MySQL
- Messaging: Apache Kafka (with Zookeeper)
- Frontend: React (Vite + TypeScript + MUI)
- Containerization: Docker, Docker Compose
- CI/CD: GitHub Actions (sample workflow provided)
- Optional: Kubernetes manifests for production

## Quickstart (Local via Docker Compose)

Prerequisites: Docker + Compose installed. If you don't have Docker locally, you can still run the services via IDE using Java 17 + Node 20.

1) Build images
```bash
docker compose build
```
2) Start all services
```bash
docker compose up -d
```
3) Access
- API Gateway: http://localhost:8080
- Eureka Dashboard: http://localhost:8761
- Frontend: http://localhost:5173

First run creates MySQL schemas automatically. Kafka auto-creates topics when first produced.

---

## Services (Overview)

- Eureka Server (service discovery)
- API Gateway (routing, auth)
- User Service (JWT auth, roles)
- Restaurant Service (restaurants, menus)
- Order Service (order lifecycle)
- Payment Service (payment simulation)
- Delivery Service (assignment, tracking)
- Notification Service (Kafka consumers)

Each service is a separate Spring Boot application with its own Dockerfile and configuration.

---

## Development

You can run each service locally via your IDE or via Docker. For Docker, build images with `docker compose build` and run `docker compose up -d`.

### Environment Variables
- `EUREKA_SERVER_URL` for all services (default points at `eureka-server` in Compose)
- `KAFKA_BOOTSTRAP` for Kafka clients (default `kafka:9092` in Compose)
- `MYSQL_*` per service (`host`, `port`, `db`, `user`, `password`)
- `JWT_SECRET` for Gateway and User Service

### Frontend
- Vite dev: `npm run dev` (env `VITE_API_BASE_URL` defaults to `http://localhost:8080`)
- Build: `npm run build`; Dockerfile serves on port 80 (exposed 5173 in Compose)

---

## Deployment

Two options provided:

1) Docker Compose (reference for local/dev)
2) Kubernetes (manifests under `k8s/`) â€“ suitable for production when paired with managed MySQL and Kafka

Steps:
- Build and push images to your registry
- Update image references in `k8s/all-in-one.yaml`
- Create namespace and apply: `kubectl apply -f k8s/all-in-one.yaml`
- Access the Gateway `Service` (LoadBalancer) to reach APIs

---

## Security

The API Gateway validates JWTs generated by the User Service. Gateway forwards identity using `X-User-Id` and `X-User-Role` headers to downstream services for authorization decisions.

Public routes: `/auth/**`, `/restaurants/**`, `/menus/**`, `/orders` GET, etc. Adjust in `api-gateway` as needed.

---

## Status

Full scaffold complete: services, gateway, discovery, messaging, database, and frontend.

Next improvements:
- Harden security per-service; add role-based auth to controllers
- Add saga/transaction choreography between Order/Payment/Delivery
- Add production-grade Kafka and MySQL with persistence, observability (Prometheus/Grafana)


# foodDeliveryApp
